# Minecraft-like Browser Starter (Single-player, saves to localStorage)

This project is a minimal, single-file browser game you can host on GitHub Pages. It uses Three.js (via CDN) and saves the world to `localStorage`. Designed to run on low-end Chromebooks in Guest mode.

---

## Files

### index.html

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>MiniCraft — Browser Voxel Demo</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <div id="ui">
    <div id="topbar">
      <button id="saveBtn">Save</button>
      <button id="loadBtn">Load</button>
      <button id="exportBtn">Export</button>
      <input id="importFile" type="file" accept="application/json" style="display:none">
      <label for="blockSelect">Block:</label>
      <select id="blockSelect">
        <option value="1">Grass</option>
        <option value="2">Dirt</option>
        <option value="3">Stone</option>
        <option value="4">Wood</option>
      </select>
      <span id="status">Click the canvas to lock pointer. Left click to remove, Right click to place</span>
    </div>
  </div>
  <script src="https://unpkg.com/three@0.152.2/build/three.min.js"></script>
  <script>
  // main.js inline for simplicity
  (function(){
    const SIZE = {x:16, y:8, z:16}; // keep small for performance
    const BLOCKS = {
      0: null,
      1: {name:'grass', color:0x7fbf3f},
      2: {name:'dirt', color:0x8b5a2b},
      3: {name:'stone', color:0x8a8a8a},
      4: {name:'wood', color:0x8b6b3a}
    };

    let scene, camera, renderer, controls;
    let world = new Uint8Array(SIZE.x*SIZE.y*SIZE.z);

    // helpers
    const idx = (x,y,z)=> (y*SIZE.z + z)*SIZE.x + x;
    const inBounds = (x,y,z)=> x>=0&&x<SIZE.x&&y>=0&&y<SIZE.y&&z>=0&&z<SIZE.z;

    // init world simple flat terrain
    function initWorld(){
      for(let x=0;x<SIZE.x;x++){
        for(let z=0;z<SIZE.z;z++){
          const h = 2 + Math.floor(Math.random()*2);
          for(let y=0;y<h;y++) world[idx(x,y,z)] = (y==h-1)?1:2; // top grass, below dirt
          for(let y=h;y<3;y++) if(Math.random()<0.02) world[idx(x,y,Math.max(0,z-1))]=3;
        }
      }
    }

    function saveWorld(){
      try{
        localStorage.setItem('mc_clone_world', JSON.stringify(Array.from(world)));
        setStatus('Saved to localStorage');
      }catch(e){setStatus('Save failed: '+e.message)}
    }
    function loadWorld(){
      const s = localStorage.getItem('mc_clone_world');
      if(!s){ setStatus('No save found'); return; }
      try{
        const arr = JSON.parse(s);
        world = Uint8Array.from(arr);
        rebuildWorldMesh();
        setStatus('Loaded from localStorage');
      }catch(e){ setStatus('Load failed: '+e.message) }
    }

    // export/import
    function exportWorld(){
      const blob = new Blob([JSON.stringify(Array.from(world))], {type:'application/json'});
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'mc_clone_world.json';
      a.click();
      setStatus('Exported world');
    }
    function importWorldFile(file){
      const r = new FileReader();
      r.onload = ()=>{
        try{
          const arr = JSON.parse(r.result);
          world = Uint8Array.from(arr);
          rebuildWorldMesh();
          setStatus('Imported world');
        }catch(e){ setStatus('Import failed: '+e.message) }
      }
      r.readAsText(file);
    }

    // three.js scene
    let cubeGroup;
    function initThree(){
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb);
      camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
      camera.position.set(SIZE.x/2, SIZE.y+2, SIZE.z+6);

      renderer = new THREE.WebGLRenderer({antialias:false});
      renderer.setSize(innerWidth, innerHeight);
      document.body.appendChild(renderer.domElement);

      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
      hemi.position.set(0,50,0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(5,10,7);
      scene.add(dir);

      // simple controls: pointer lock + mouse look + keyboard
      setupControls(renderer.domElement);

      cubeGroup = new THREE.Group();
      scene.add(cubeGroup);

      window.addEventListener('resize', ()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth, innerHeight)});
    }

    function rebuildWorldMesh(){
      // clear
      while(cubeGroup.children.length) cubeGroup.remove(cubeGroup.children[0]);
      for(let x=0;x<SIZE.x;x++){
        for(let y=0;y<SIZE.y;y++){
          for(let z=0;z<SIZE.z;z++){
            const b = world[idx(x,y,z)];
            if(b){
              const geo = new THREE.BoxGeometry(1,1,1);
              const mat = new THREE.MeshLambertMaterial({color:BLOCKS[b].color});
              const m = new THREE.Mesh(geo, mat);
              m.position.set(x, y, z);
              cubeGroup.add(m);
            }
          }
        }
      }
    }

    // raycasting for block interaction
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    function screenToRay(x,y){
      mouse.x = (x / innerWidth) * 2 - 1;
      mouse.y = - (y / innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      return raycaster;
    }

    function placeOrRemoveBlock(isPlace){
      const rc = screenToRay(innerWidth/2, innerHeight/2);
      const intersects = rc.intersectObjects(cubeGroup.children);
      if(intersects.length===0){ setStatus('No block targeted'); return; }
      const hit = intersects[0];
      const pos = hit.object.position.clone();
      if(isPlace){
        const normal = hit.face.normal;
        const nx = pos.x + normal.x;
        const ny = pos.y + normal.y;
        const nz = pos.z + normal.z;
        const xi=Math.round(nx), yi=Math.round(ny), zi=Math.round(nz);
        if(!inBounds(xi,yi,zi)){ setStatus('Out of bounds'); return; }
        const sel = parseInt(document.getElementById('blockSelect').value);
        if(world[idx(xi,yi,zi)]===0){ world[idx(xi,yi,zi)]=sel; rebuildWorldMesh(); setStatus('Placed block'); }
      }else{
        const xi=Math.round(pos.x), yi=Math.round(pos.y), zi=Math.round(pos.z);
        if(!inBounds(xi,yi,zi)){ setStatus('Out of bounds'); return; }
        world[idx(xi,yi,zi)] = 0; rebuildWorldMesh(); setStatus('Removed block');
      }
    }

    // controls implementation
    let move = {f:0, b:0, l:0, r:0, up:0};
    let velocity = new THREE.Vector3();
    let pitchObject, yawObject;
    function setupControls(dom){
      // create camera holder
      pitchObject = new THREE.Object3D();
      pitchObject.add(camera);
      yawObject = new THREE.Object3D();
      yawObject.position.set(SIZE.x/2, SIZE.y+1.5, SIZE.z/2);
      yawObject.add(pitchObject);
      scene.add(yawObject);

      const onKey=(e)=>{
        const down = e.type==='keydown';
        if(e.code==='KeyW') move.f = down?1:0;
        if(e.code==='KeyS') move.b = down?1:0;
        if(e.code==='KeyA') move.l = down?1:0;
        if(e.code==='KeyD') move.r = down?1:0;
        if(e.code==='Space' && down) { velocity.y = 0.12 }
      }
      window.addEventListener('keydown', onKey);
      window.addEventListener('keyup', onKey);

      // pointer lock
      dom.addEventListener('click', ()=>{
        dom.requestPointerLock?.();
      });
      document.addEventListener('pointerlockchange', ()=>{
        const locked = document.pointerLockElement === dom;
        setStatus(locked ? 'Pointer locked — use WASD to move' : 'Pointer unlocked');
      });
      document.addEventListener('mousemove', (e)=>{
        if(document.pointerLockElement !== dom) return;
        const movementX = e.movementX || 0;
        const movementY = e.movementY || 0;
        yawObject.rotation.y -= movementX * 0.002;
        pitchObject.rotation.x -= movementY * 0.002;
        pitchObject.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitchObject.rotation.x));
      });

      // mouse buttons
      window.addEventListener('mousedown', (e)=>{
        if(document.pointerLockElement !== dom) return;
        if(e.button === 0) placeOrRemoveBlock(false); // left = remove
        if(e.button === 2) placeOrRemoveBlock(true);  // right = place
      });
      // prevent context menu
      window.addEventListener('contextmenu', (e)=>{ e.preventDefault(); });
    }

    function animate(){
      requestAnimationFrame(animate);
      // movement
      const speed = 0.06;
      const dir = new THREE.Vector3();
      if(move.f) dir.z -= 1;
      if(move.b) dir.z += 1;
      if(move.l) dir.x -= 1;
      if(move.r) dir.x += 1;
      dir.normalize();
      const matrix = new THREE.Matrix4();
      matrix.extractRotation(yawObject.matrix);
      dir.applyMatrix4(matrix);
      yawObject.position.addScaledVector(dir, speed);

      // simple gravity
      velocity.y -= 0.005;
      yawObject.position.y += velocity.y;
      if(yawObject.position.y < 1.5){ velocity.y = 0; yawObject.position.y = 1.5; }

      renderer.render(scene, camera);
    }

    function setStatus(s){ document.getElementById('status').textContent = s; }

    // UI hooks
    document.addEventListener('DOMContentLoaded', ()=>{
      initThree();
      const saved = localStorage.getItem('mc_clone_world');
      if(saved) loadWorld(); else { initWorld(); rebuildWorldMesh(); }
      animate();

      document.getElementById('saveBtn').addEventListener('click', saveWorld);
      document.getElementById('loadBtn').addEventListener('click', loadWorld);
      document.getElementById('exportBtn').addEventListener('click', exportWorld);
      document.getElementById('importFile').addEventListener('change', (ev)=>{ if(ev.target.files[0]) importWorldFile(ev.target.files[0]); });
    });

  })();
  </script>
</body>
</html>
```

### style.css

```css
html,body{margin:0;height:100%;overflow:hidden;font-family:system-ui,Segoe UI,Roboto,Arial}
#ui{position:absolute;left:8px;top:8px;z-index:20}
#topbar{background:rgba(255,255,255,0.9);padding:6px;border-radius:6px;display:flex;gap:8px;align-items:center}
#status{font-size:12px;color:#333}
button{padding:6px 8px}
select{padding:4px}
```

---

## How to use / deploy to GitHub Pages

1. Create a new public GitHub repository. Name it e.g. `mini-mc`.
2. Add the three files above (`index.html`, `style.css`). (Here we put JS inline for simplicity.)
3. Commit and push to `main` branch.
4. In repo **Settings → Pages**, choose `main` branch and `/ (root)` folder, save.
5. Visit `https://<yourusername>.github.io/<repo>/` to play.

Players can save progress — it's stored in their browser's `localStorage`. They can also `Export` a JSON file and `Import` it on another device manually.

---

## Notes & next steps

* This is intentionally minimal so you can run it on low-end Chromebooks. Performance tuning ideas: reduce `SIZE`, merge geometries, or use `InstancedMesh` for lots of blocks.
* If you want cloud saves later, we can add Firebase auth + Firestore to sync saves between devices.
* If you'd prefer separate files (cleaner structure) or a ZIP you can download, tell me and I will prepare that.

Enjoy! Open the file to view the code and run it in your browser. If you want, I can now:

* Convert this into a downloadable ZIP file,
* Break the inline script into `main.js` and adjust the HTML,
* Or prepare a ready-to-paste GitHub repo with instructions.

Tell me which next step you want.
